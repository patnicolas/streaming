/**
 * Copyright 2022,2023 Patrick R. Nicolas. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance
 * with the License. A copy of the License is located at
 *
 * http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 * OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 */
package org.pipeline.streams.spark.weatherTracking

import scala.util.Random

/**
 * Definition of data generated by Doppler radar station
 *
 * @param id Identifier for the source of Doppler radar data
 * @param longitude Longitude of the source of Doppler radar data
 * @param latitude Latitude of the source of Doppler radar data
 * @param timeStamp Time stamp for the new Doppler radar data
 * @param windShear Boolean flag to specify if this is a wind shear
 * @param windSpeed Average speed for the wind (miles/hour)
 * @param gustSpeed Maximum speed for the wind (miles/hour)
 * @param windDirection Direction of the wind [0, 360] degrees
 *
 * @author Patrick Nicolas
 */
@throws(clazz = classOf[IllegalArgumentException])
private[weatherTracking] case class DopplerData(
  override val id: String, // Identifier for the weather station
  override val longitude: Float, // Longitude for the weather station
  override val latitude: Float, // Latitude for the weather station
  override val timeStamp: String = System.currentTimeMillis().toString, // Time stamp data is
  // collected
  windShear: Boolean = false,
  windSpeed: Float = 2.5F,
  gustSpeed: Float = 6.0F,
  windDirection: Int = 22) extends TrackingData[DopplerData] {

  require(windSpeed >= 0.0F && windSpeed <= 450.0F,
    s"Wind speed $windSpeed should be [0, 450] miles/hour")
  require(gustSpeed >= 0.0F && gustSpeed <= 450.0F,
    s"Gusts speed $gustSpeed should be [0, 450] miles/hour")
  require(windSpeed <= gustSpeed,
    s"Wind speed $windSpeed should be < gust speed $gustSpeed")
  require(windDirection >= 0 && windDirection < 360, s"Wind direction should be [0, 360[")

  /**
   * Add noise to this instance of Doppler radar data
   * @param rand Random generator instance
   * @param alpha Scale factor applied to uniform randomly distributed noise
   * @return Noisy duplicate of Doppler data
   */
  def rand(rand: Random, alpha: Float): DopplerData = this.copy(
    timeStamp = (timeStamp.toLong + 10000L + rand.nextInt(2000)).toString,
    windShear = rand.nextBoolean(),
    windSpeed = windSpeed * (1 + alpha * rand.nextFloat()),
    gustSpeed = gustSpeed * (1 + alpha * rand.nextFloat()),
    windDirection = {
      val newDirection = windDirection * (1 + alpha * rand.nextFloat())
      if(newDirection > 360.0) newDirection.toInt%360 else newDirection.toInt
    }
  )

  override def toString: String = s"$id;$longitude;$latitude;$timeStamp;$windShear;$windSpeed;" +
    s"$gustSpeed;$windDirection"
}


/**
 * Singleton for Doppler radar data
 * - Encoder/Decoder for Kafka channels
 * - Various constructors
 */
private[weatherTracking] object DopplerData {

  object DopplerDataEncoder extends DataEncoder[DopplerData] {
    def unapply(encodedDopplerData: String): DopplerData =
      super.unapply(
        encodedDopplerData,
        (fields: Seq[String]) => DopplerData(
          fields.head,
          fields(1).toFloat,
          fields(2).toFloat,
          fields(3),
          fields(4).toBoolean,
          fields(5).toFloat,
          fields(6).toFloat,
          fields(7).toInt
        )
      )
  }

  def apply(
    filename: String,
    loader: String => Seq[DopplerData]
  ): Seq[DopplerData] = loader(filename)

  def apply(
    initialStations: Seq[(String, Float, Float)],
    numSamplesPerStation: Int,
    scaleFactor: Float
  ): Seq[DopplerData] = {

    val seedStations = initialStations.map { case (id, long, lat) => DopplerData(id, long, lat)}
    val rand = new Random(42L)
    seedStations.flatMap(
      seedStation => (0 until numSamplesPerStation).map(
        _ => seedStation.rand(rand, scaleFactor)
      )
    )
  }
}
